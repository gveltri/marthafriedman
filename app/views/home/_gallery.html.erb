<script>
    Physijs.scripts.worker = '<%= asset_path 'physijs_worker.js' %>';
    Physijs.scripts.ammo = '<%= asset_path 'ammo.js' %>';


var initScene, render, renderer, scene, camera, initEventHandling;

var dir_light, dir_light2, am_light, spot_light, point_light;

var moveable_objects = [], selected_thing = null, static_surfaces=[],
    intersect_planes = [], sculptures=[];

var mouse_position = new THREE.Vector3, _v3 = new THREE.Vector3,
    module_factor = new THREE.Vector3( 0, 0.5, 0 ), armature_factor = new THREE.Vector3( 0, 0, 0 );

initScene = function() {
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;
    renderer.setClearColor( 0xece7eb );

    document.getElementById('container').appendChild(renderer.domElement);
    //allows keydown to be heard
    renderer.domElement.setAttribute("tabindex", 0);
    renderer.sortObjects = true;

    // Initialize Physijs Scene
    scene = new Physijs.Scene();
    scene.setGravity( new THREE.Vector3(0, -40, 0) );

    // Click-and-drag functionality
    scene.addEventListener( 'update', function() {
	if ( selected_thing !== null ) {
	    _v3.copy( mouse_position ).sub( selected_thing.position ).multiplyScalar( 5 );
	    selected_thing.setLinearVelocity( _v3 );
	    _v3.set( 0, 0, 0 );
	    for ( _i = 0; _i < moveable_objects.length; _i++ ) {
		moveable_objects[_i].applyCentralImpulse( _v3 );
	    }
	}
	scene.simulate( undefined, 1 );
    });

    // camera
    camera = new THREE.PerspectiveCamera(
    	35,
    	window.innerWidth / window.innerHeight,
    	    1,
    	1000
    );
    camera.position.set(120,50,80);
    camera.lookAt(scene.position);

    // ambient light
    am_light = new THREE.AmbientLight( 0x444444 );
    scene.add( am_light );

    //point light
    point_light = new THREE.PointLight( 0xFFFFFF, 0.5, 100 );
    point_light.position.set( -15, 20, -30 );
    scene.add( point_light );

    // directional lights
    dir_light = new THREE.DirectionalLight( 0xFFFFFF );
    dir_light.position.set( 20, 30, -5 );
    dir_light.target.position.copy( scene.position );
    dir_light.castShadow = true;
    dir_light.shadowCameraLeft = -100;
    dir_light.shadowCameraTop = -100;
    dir_light.shadowCameraRight = 100;
    dir_light.shadowCameraBottom = 100;
    dir_light.shadowCameraNear = 0;
    dir_light.shadowCameraFar = 100;
    dir_light.shadowBias = -.001
    dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
    dir_light.shadowDarkness = .3;

    scene.add( dir_light );

    dir_light2 = new THREE.DirectionalLight( 0xFCD440);
    dir_light2.position.set( 5, 30, 20 );
    dir_light2.target.position.copy( scene.position );
    dir_light2.castShadow = true;
    dir_light2.shadowCameraLeft = -100;
    dir_light2.shadowCameraTop = -100;
    dir_light2.shadowCameraRight = 100;
    dir_light2.shadowCameraBottom = 100;
    dir_light2.shadowCameraNear = 0;
    dir_light2.shadowCameraFar = 100;
    dir_light2.shadowBias = -.001
    dir_light2.shadowMapWidth = dir_light2.shadowMapHeight = 2048;
    dir_light2.shadowDarkness = .1;
    dir_light2.intensity = 0.3;

    scene.add( dir_light2 );

    //spot light for sculptures
    spot_light = new THREE.SpotLight( 0xFFFFFF );
    spot_light.angle = Math.PI/10;
    spot_light.position.set( 0, 30, 0 );
    spot_light.intensity = 0;
    spot_light.castShadow = true;
    scene.add(spot_light);
    

    //space init
    Table(-50,-15,-55,120,50,'<%= asset_path 'concrete_1.jpg' %>',0);
    Table(-70,-15,0,80,80,'<%= asset_path 'concrete_1.jpg' %>',0);
    Table(0,-15.5,10,60,80,'<%= asset_path 'grass.jpg' %>',0);

	//sculptures init
    
    oliveSculpture(-10,-55);
    hairballSculpture(-65, 20);
    wedgeSculpture(-60,-55);
    eggSculpture(-70,-10);
    //eggSculpture(-60,-30);

    sculptures.forEach(function(sculpture) {
	sculpture.addIntersectSphere();
    });

    //intersection planes
    
    intersectionPlanes();

    initEventHandling(); //handle mouse clicks
    requestAnimationFrame( render ); //render scene
};

function intersectionPlanes() {
    var intersect_plane = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 400, 400 ),
	new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0 , transparent: true })
    );
    intersect_plane.rotation.x = Math.PI / -2;
    scene.add( intersect_plane );

    var intersect_plane_y = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 600, 300),
	new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0 , transparent: true })
    );
    intersect_plane_y.position.set(-60,0,-35);
    intersect_plane_y.rotation.y = Math.PI/ 10;
    scene.add( intersect_plane_y );

    var intersect_plane_z = new THREE.Mesh(
    	new THREE.PlaneBufferGeometry( 600, 300),
    	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0 , transparent: true })
    );

    intersect_plane_z.rotation.y = Math.PI/ 1.9;
    intersect_plane_z.position.set(-60, 0, -35)
    scene.add( intersect_plane_z );

    intersect_planes.push(intersect_plane);
    intersect_planes.push(intersect_plane_y);
    intersect_planes.push(intersect_plane_z);
}


function Table(x,y,z,x_size,y_size,texture_path,rotation) {

    rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);

    var table_texture = new THREE.ImageUtils.loadTexture( texture_path );
    table_texture.wrapS = table_texture.wrapT = THREE.RepeatWrapping;
    table_texture.repeat.set(3,3);

    var table_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: table_texture, ambient: 0xFFFFFF }),
	0.8,
	0.9);

    var table = new Physijs.BoxMesh(
	new THREE.BoxGeometry(x_size,1,y_size),
	table_material,
	0
    );

    table.receiveShadow = true;
    table.position.set(x,y,z);
    table.rotation.y = rotation;

    scene.add( table );
    static_surfaces.push(table);
};


function Wall(x,y,z,x_size,y_size,texture_path,rotation,visible) {

    rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);
    visible = typeof visible !== 'undefined' ? visible : true;

    var wall_texture = new THREE.ImageUtils.loadTexture( texture_path );
    wall_texture.wrapS = wall_texture.wrapT = THREE.RepeatWrapping;
    wall_texture.repeat.set(3,3);

    var wall_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: wall_texture, ambient: 0xFFFFFF }),
	0.8,
	0.9);

    if (!visible) wall_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({opacity: 0, transparent: true  }),
	0.8,
	0.9
    );

    var wall = new Physijs.BoxMesh(
	new THREE.BoxGeometry(x_size,1,y_size),
	wall_material,
	0
    );

    wall.receiveShadow = true;
    wall.castShadow = true;
    wall.position.set(x,y,z);
    wall.rotation.z = Math.PI / 2;
    wall.rotation.y = rotation;

    scene.add( wall );
    static_surfaces.push(wall);
};

//Hairball Constructor
function hairballSculpture(x,z) {

    var box_material = Physijs.createMaterial(
	new THREE.MeshLambertMaterial({ color: 0xFF66FF }),
	0.9,
	0.2);

    var box = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 10, 10, 10 ),
	box_material,
	30
    );

    box.position.set(x, -9.4, z);
    box.castShadow = true;
    box.receiveShadow = true;

    scene.add( box );

    box.setAngularFactor( armature_factor );
    box.setLinearFactor( armature_factor );

    var sphere_texture = THREE.ImageUtils.loadTexture('<%= asset_path 'hair.jpg' %>',THREE.SphericalRefractionMapping);
    sphere_texture.wrapS = sphere_texture.wrapT = THREE.RepeatWrapping;
    sphere_texture.repeat.set(3,3);
    
    var sphere_material = Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: sphere_texture, ambient: 0x904716 }),
	0.5,
	0.9);
    
    var sphere = new Physijs.SphereMesh(
	new THREE.SphereGeometry(5,20,20),
	sphere_material,
	9
    );
    
    sphere.position.set(x, 5, z);
    sphere.castShadow = true;
    sphere.receiveShadow= true;
    scene.add( sphere );
    moveable_objects.push( sphere );

    sphere.setAngularFactor( module_factor );
    sphere.setLinearFactor( module_factor );
    
    new Sculpture(box,[sphere],1);
}
//end hairball constructor

function oliveSculpture(x,z) {
    var olives = [];
    
    var armature = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 4, 4, 4 ),
	new THREE.MeshLambertMaterial({ color: 0xEEEEEE }),
	9
    );

    armature.position.set(x,-12.5, z);
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
	new THREE.CylinderGeometry(0.3,0.3,45.8),
	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder.position.set(x, 5,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;
    scene.add(intersect_cylinder);

    OliveCreator(13);
    new Sculpture( armature, olives);
    
    function OliveCreator(num) {

	var olive_loader = new THREE.PLYLoader();

	var olive_material = new Physijs.createMaterial (
	    new THREE.MeshPhongMaterial({ color: 0x00FFFF, ambient: 0x904716}),
	    0.5,
	    0.5
	);

	var olive = olive_loader.load('<%= asset_path 'ascii/Olive_nopimento.ply' %>', function( geometry ){

	    var m = new THREE.Matrix4();
	    var m1 = new THREE.Matrix4();

	    m.makeRotationX( Math.PI/2 );
	    m1.makeRotationZ( Math.PI/2 );
	    m.multiply( m1 );
	    geometry.applyMatrix(m);
	    geometry.computeBoundingBox();

	    var radius = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
	    var armature_y = -7.6;
	    var pimento_material = new THREE.MeshPhongMaterial({color: 0xFF0000});

	    for (var i = 0; i < num; i++) {

		var y = armature_y + (olives.length * (radius));

		var oliveMesh = new Physijs.CylinderMesh(
		    geometry,
		    olive_material,
		    5
		);

		var pimento = new THREE.Mesh(
		    new THREE.CylinderGeometry(1.5,1.5,1.5,5),
		    pimento_material
		);
		pimento.position.x = -0.5;
		pimento.position.z = 2;
		

		oliveMesh.add(pimento);

		oliveMesh.castShadow = true;
		oliveMesh.receiveShadow = true;

		oliveMesh.position.set(armature.position.x, y, armature.position.z);
		oliveMesh.scale.set(0.6,0.55,0.6);


		scene.add( oliveMesh );

		oliveMesh.setAngularFactor( module_factor );
		oliveMesh.setLinearFactor( module_factor );

		olives.push(oliveMesh);
		moveable_objects.push(oliveMesh);
	    }
	});
    }
}

function eggSculpture(x,z) {
    var eggs = [];
    var armature = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 5, 1, 5 ),
	new THREE.MeshPhongMaterial({ color: 0xEEEEEE }),
	9
    );

    armature.position.set(x,-14, z);
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
	new THREE.CylinderGeometry(0.25,0.25,40.8),
	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder.position.set(x,3,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;

    scene.add(intersect_cylinder);

    EggCreator(5);
    new Sculpture( armature, eggs );

    function EggCreator(num) {

    	var egg_loader = new THREE.PLYLoader();

    	var egg_material = new Physijs.createMaterial (
	    new THREE.MeshLambertMaterial({ color: 0xEEEEEE, emissive: 0xDDDDDD}),
	    0.1,
	    0.7
	);

	var egg = egg_loader.load('<%= asset_path 'ascii/Egg.ply' %>', function( geometry ){
	    
	    var m = new THREE.Matrix4();
	    var m1 = new THREE.Matrix4();
	    
	    m.makeTranslation(0,-8,0);
	    m1.makeRotationY( Math.PI/2 );
	    m.multiply(m1).multiplyScalar(0.5);
	    geometry.applyMatrix(m);
	    
	    for (var i = 0; i < num; i++){
	    	var y = -8 + (eggs.length*10);

		
	    	var eggMesh = new Physijs.ConvexMesh(
	    		geometry,
	    		egg_material,
	    		7
	    	);


	    	eggMesh.castShadow = true;
	    	eggMesh.receiveShadow = true;
		eggMesh.position.set(armature.position.x, y, armature.position.z);
		
	    	scene.add( eggMesh );
		
		eggMesh.__dirtyRotation = true;
		eggMesh.rotation.x = Math.PI/2;
	    	if (i%2==0) eggMesh.rotation.z = Math.PI/2;
		
	    	eggMesh.setAngularFactor( module_factor );
	    	eggMesh.setLinearFactor( module_factor );

	    	eggs.push(eggMesh);
	    	moveable_objects.push(eggMesh);
	    }
	});
    }
}

function wedgeSculpture(x,z) {
    var wedges = [];
    var armature = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 20, .5, 20 ),
	new THREE.MeshPhongMaterial({ color: 0xEEEEEE }),
	9
    );

    armature.position.set(x,-14.5, z);
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder_one = new THREE.Mesh(
	new THREE.CylinderGeometry(0.25,0.25,40.8),
	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder_one.position.set(x + .75 ,3 , z - .75);
    intersect_cylinder_one.castShadow = true;
    intersect_cylinder_one.receiveShadow = true;

    var intersect_cylinder_two = new THREE.Mesh(
	new THREE.CylinderGeometry(0.25,0.25,40.8),
	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder_two.position.set(x - .75 ,3 ,z + .75);
    intersect_cylinder_two.castShadow = true;
    intersect_cylinder_two.receiveShadow = true;

    scene.add(intersect_cylinder_one);
    scene.add(intersect_cylinder_two);

    // flatWedgeCreator will add flat wedges to the wedges array in the appropriate positions
    // The structure of the wedge stack is hard coded to match the existing sculpture
    // if it needs to be dynamic we can revisit
    flatWedgeCreator();
    new Sculpture( armature, wedges );

    function flatWedgeCreator() {
    	var num = 47;

    	var wedge_loader = new THREE.PLYLoader();

    	var wedge_material = new Physijs.createMaterial (
	    	// we need to work on these materials etc... I guess we know that though
	    	new THREE.MeshLambertMaterial({ color: 0x000000, emissive: 0xDDDDDD}),
	    	0.1,
	    	.1
	);

	var wedge_flat = wedge_loader.load('<%= asset_path 'ascii/Wedge_Flat.ply' %>', function( geometry ){
	    
	    var m = new THREE.Matrix4();
	    //var m1 = new THREE.Matrix4();
	   	var geo_left = geometry.clone();

	    // m.makeTranslation(-1.0, -8, 3.8);
	    m.makeRotationY( Math.PI );
	    // m.multiplyScalar( 2 );
	    

	   	geometry.applyMatrix(m);

	    // console.log(geometry.boundingSphere.radius);

	    var yFactor = geometry.boundingSphere.radius;
	   	
	    for (var i = 0; i < num; i++){
	    	var y = (wedges.length * 1.2) - 14;

	    	var geo;
	    	
	    	if ( i % 2 == 0) {
	    		geo = geo_left;
	    	}
	    	else {
	    		geo = geometry;
	    	}

	    	var wedgeMesh = new Physijs.ConvexMesh(
	    		geo,
	    		wedge_material,
	    		0.5
	    	);

	    	wedgeMesh.castShadow = true;
	    	wedgeMesh.receiveShadow = true;
			wedgeMesh.position.set(armature.position.x, y, armature.position.z);
		
	    	scene.add( wedgeMesh );
		
			wedgeMesh.__dirtyRotation = true;
			// wedgeMesh.rotation.x = Math.PI/2;
		
	    	wedgeMesh.setAngularFactor( new THREE.Vector3(0,0,0) );
	    	wedgeMesh.setLinearFactor( module_factor );

	    	wedges.push(wedgeMesh);
	    	moveable_objects.push(wedgeMesh);
	    }
	});
    }
}

// relates armature and modules
var Sculpture = function(armature,modules,limit) {
    this.armature = armature;
    this.modules = modules;
    this.limit = limit || 50;
    this.intersect_sphere;

    // add scupture object to array of sculptures
    sculptures.push(this);
};

Sculpture.prototype.removeModule = function(obj) {
	this.modules.splice(this.modules.indexOf(obj),1);
	if (this.modules.length == 0) {
		moveable_objects.push(this.armature);
		this.limit = 0;		
	}
};

Sculpture.prototype.addModule = function(obj) {
    var snap_y;
    if (!this.isAtLimit()) {
	if (this.modules.length == 0) {
	    snap_y = -6
		+ this.armature.geometry.boundingBox.max.y
		+ obj.geometry.boundingSphere.radius;
	}
	else {
	    snap_y = this.modules[this.modules.length-1].position.y
		+ this.modules[this.modules.length-1].geometry.boundingBox.max.y
		+ obj.geometry.boundingBox.max.y;
	}

	//put object in position
	obj.__dirtyPosition = true;
	obj.position.set( this.armature.position.x,
			  snap_y,
			  this.armature.position.z );

	//make object static
	_v3 = new THREE.Vector3(0,1,0);
	obj.setAngularFactor(_v3);
	obj.setLinearFactor(_v3);
	_v3 = new THREE.Vector3(0,0,0);
	obj.setLinearVelocity(_v3);

	//finally, push selected_thing on the sculpture stack
	this.modules.push( obj );
    }
};

Sculpture.prototype.isAtLimit = function() {
    return ( this.modules.length >= this.limit ) ? true : false;
};

Sculpture.prototype.addIntersectSphere = function() {
    // this.intersect_sphere = new THREE.Mesh(
    // 	new THREE.SphereGeometry( 10 ),
    // 	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 1 , transparent: true })
    // );
    
    // if (modules.length > 0) {
    // 	this.intersect_sphere.position.copy(this.modules[this.modules.length-1].position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // else {
    // 	this.intersect_sphere.position.copy(this.armature.position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // scene.add(this.intersect_sphere);

}

//user input
initEventHandling = (function() {
    var handleMouseDown, handleMouseMove, handleMouseUp, handleKeyDown, handleResize;
    var raycaster = new THREE.Raycaster();
    var thing_offset = new THREE.Vector3;
    var _vector = new THREE.Vector3();
    var sculpture, collisionResults, intersections, intersection;
    var spot_light_on = false;

    handleResize = function( evt ) {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
    };

    handleMouseDown = function( evt ) {


	_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
		    -(evt.clientY / window.innerHeight ) * 2 + 1,
		    1);

	raycaster.setFromCamera(_vector, camera);
	intersections = raycaster.intersectObjects( moveable_objects );

	if (intersections.length > 0) {
	    selected_thing = intersections[0].object;

	    // if it is on a sculpture, pop it and make it dynamic
	    for (i = 0; i < sculptures.length; i++) {
		if (sculptures[i].modules.indexOf(selected_thing) >= 0) {
		    sculptures[i].removeModule(selected_thing);
		    break;
		}
	    }


	    _vector.set(0,0,0);
	    selected_thing.setAngularFactor( _vector);
	    selected_thing.setAngularVelocity( _vector);
	    selected_thing.setLinearFactor( _vector);
	    selected_thing.setLinearVelocity( _vector);

	    mouse_position.copy(intersections[0].point);
	    thing_offset.subVectors( selected_thing.position, mouse_position);

	}
	else {
	    intersections = raycaster.intersectObjects( static_surfaces );
	    if (intersections.length > 0) {
		for (var i = 0; i < moveable_objects.length; i++) {
		    _v3 = moveable_objects[i].getLinearVelocity();
		    if (Math.abs(_v3.y) < 2 ) moveable_objects[i].applyCentralImpulse(new THREE.Vector3(0,50,0));
		}
	    }
	}

    };

    handleMouseMove = function( evt ) {

	if (selected_thing !== null) {

	    _vector.set(
		( evt.clientX / window.innerWidth ) * 2 - 1,
		    -( evt.clientY / window.innerHeight ) * 2 + 1,
		1);

	    raycaster.setFromCamera(_vector, camera);
	    intersection = raycaster.intersectObjects( intersect_planes );
	    if ( intersection[0] != undefined) {
		mouse_position.copy(intersection[0].point);
	    }

	    //iterates through sculpture objects
	    for (i = 0; i < sculptures.length; i++) {
		collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
		if (collisionResults.length !== 0 && !sculptures[i].isAtLimit()) {
		    sculpture = sculptures[i];
		    
		    //make a light source directly above the sculpture
		    spot_light.position.set( sculpture.armature.position.x, spot_light.position.y, sculpture.armature.position.z );
		    spot_light.target = sculpture.armature;
		    spot_light.intensity = 1;
		    spot_light_on = true;
		    
		    break;
		}
		else if ( spot_light_on ) { //if the light source is on
		    spot_light.intensity = 0;
		}
	    }
	}
    };

    handleMouseUp = function( evt ) {

	if (selected_thing !== null) {

	    _vector.set(1,1,1);
	    selected_thing.setAngularFactor( _vector );
	    selected_thing.setLinearFactor( _vector );

	    // snapping to armature
		_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
			-(evt.clientY / window.innerHeight ) * 2 + 1,
			1);

	    raycaster.setFromCamera(_vector, camera);

	    //iterates through sculpture objects
	    for (i = 0; i < sculptures.length; i++) {
		collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
		if (collisionResults.length !== 0) {
		    sculpture = sculptures[i];
		    break;
		}
	    }

	    if ( collisionResults.length !== 0) {

		sculpture.addModule( selected_thing );

		//turn off spotlight
		spot_light.intensity = 0;


	    }
	    //end snapping

	    selected_thing = null;
	}
    };

    //rotate camera
    handleKeyDown =  function( evt ){

	var x = camera.position.x,
	    y = camera.position.y,
	    z = camera.position.z;
	var rotSpeed = 0.05;

	if (evt.keyCode=="37"){
	    camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
	    camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
	}

	else if (evt.keyCode=="39"){
	    camera.position.x = x * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
	    camera.position.z = z * Math.cos(rotSpeed) + x * Math.sin(rotSpeed);
	}

	camera.lookAt(scene.position);

    }

    return function() {
	renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
	renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
	renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
	renderer.domElement.addEventListener( 'keydown', handleKeyDown );
	window.addEventListener('resize', handleResize );
    };
})();

//render loop
render = function() {
    scene.simulate(); // run physics
    renderer.render( scene, camera); // render the scene
    requestAnimationFrame( render );
};

initScene();
</script>
    
