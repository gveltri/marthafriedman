<!-- For the Future
1) Load PLY objects as binary
2) Bring soft body action from Ammo through Physijs and THREE
-->
<script>
    Physijs.scripts.worker = '<%= asset_path 'physijs_worker.js' %>';
    Physijs.scripts.ammo = '<%= asset_path 'ammo.js' %>';


var initScene, render, renderer, scene, camera, initEventHandling;

var dir_light, dir_light2, am_light, spot_light, point_light;

var moveable_objects = [], selected_thing = null, static_surfaces=[],
    intersect_planes = [], sculptures=[];

var mouse_position = new THREE.Vector3, _v3 = new THREE.Vector3,
    module_factor = new THREE.Vector3( 0, 0.5, 0 ), armature_factor = new THREE.Vector3( 0, 0, 0 );

initScene = function() {
    renderer = new THREE.WebGLRenderer({ antialias:true }); //alpha: true
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;
    renderer.setClearColor( 0xece7eb, 0 );

    document.getElementById('container').appendChild(renderer.domElement);
    //allows keydown to be heard
    renderer.domElement.setAttribute("tabindex", 0);

    renderer.sortObjects = true;

    // Initialize Physijs Scene
    scene = new Physijs.Scene();
    scene.setGravity( new THREE.Vector3(0, -90, 0) );

    // Click-and-drag functionality
    scene.addEventListener( 'update', function() {
	if ( selected_thing !== null ) {
	    _v3.copy( mouse_position ).sub( selected_thing.position ).multiplyScalar( 5 );
	    selected_thing.setLinearVelocity( _v3 );
	    _v3.set( 0, 0, 0 );
	    for ( _i = 0; _i < moveable_objects.length; _i++ ) {
		moveable_objects[_i].applyCentralImpulse( _v3 );
	    }
	}
	scene.simulate( undefined, 1 );
    });

    // camera
    camera = new THREE.PerspectiveCamera(
    	35,
    	window.innerWidth / window.innerHeight,
    	    1,
    	1000
    );
    camera.position.set(120,50,80);
    camera.lookAt(scene.position);

    // ambient light
    am_light = new THREE.AmbientLight( 0xF0F0F0 );
    scene.add( am_light );

    //point light
    point_light = new THREE.PointLight( 0xFFFFFF, 0.5, 100 );
    point_light.position.set( -15, 20, -30 );
    scene.add( point_light );

    // directional lights
    dir_light = new THREE.DirectionalLight( 0x404040 );
    dir_light.position.set( 20, 30, -5 );
    dir_light.target.position.copy( scene.position );
    dir_light.castShadow = true;
    dir_light.shadowCameraLeft = -100;
    dir_light.shadowCameraTop = -100;
    dir_light.shadowCameraRight = 100;
    dir_light.shadowCameraBottom = 100;
    dir_light.shadowCameraNear = 0;
    dir_light.shadowCameraFar = 150;
    dir_light.shadowBias = .001
    dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
    dir_light.shadowDarkness = .3;

    scene.add( dir_light );

    dir_light2 = new THREE.DirectionalLight( 0x404040);
    dir_light2.position.set( 5, 30, 20 );
    dir_light2.target.position.copy( scene.position );
    dir_light2.castShadow = true;
    dir_light2.shadowCameraLeft = -100;
    dir_light2.shadowCameraTop = -100;
    dir_light2.shadowCameraRight = 100;
    dir_light2.shadowCameraBottom = 100;
    dir_light2.shadowCameraNear = 0;
    dir_light2.shadowCameraFar = 150;
    dir_light2.shadowBias = .001
    dir_light2.shadowMapWidth = dir_light2.shadowMapHeight = 2048;
    dir_light2.shadowDarkness = .1;
    dir_light2.intensity = 0.3;

    scene.add( dir_light2 );

    //spot light for sculptures
    spot_light = new THREE.SpotLight( 0xFFFFFF, 0, 70, Math.PI/10, 65, 1 );
    //spot_light.angle = Math.PI/10;
    spot_light.position.set( 0, 30, 0 );
    //spot_light.intensity = 0;
    spot_light.castShadow = true;
    spot_light.shadowBias = -.00001
    spot_light.shadowMapWidth = spot_light.shadowMapHeight = 2048;
    scene.add(spot_light);
    

    //space init

    // make less heavy
    Table( 0, -18, -40, 50, 3, 50, '<%= asset_path 'parquet_2.jpg' %>', Math.PI / 2, 8, 8 );    
    Table( -50, -17.25, -15, 50, 3, 100, '<%= asset_path 'concrete_1.jpg' %>', 0, 5, 17);
    Table( -25, -19.25, -15, 100, 2, 100,'<%= asset_path 'grass.jpg' %>', Math.PI / 2, 3, 3);

	//sculptures init
     
    oliveSculpture(0,-40);
    hairballSculpture(-50, 20);
    eggSculpture(-50,-5);

    // New way to make a sculptures
    var wedgeAssets = ['<%= asset_path 'ascii/Wedge_Flat.ply' %>', '<%= asset_path 'ascii/Wedge_Hammerhead.ply' %>', '<%= asset_path 'ascii/LongWedge.ply' %>'];
    LoadPlyAssets(wedgeAssets, wedgeSculpture);    // default x: -50 , z: -40

    var tongueAssets = ['<%= asset_path 'ascii/Tongue_up2.ply' %>'];
    LoadPlyAssets(tongueAssets, TongueSculpture); 
   
    // sculptures.forEach(function(sculpture) {
	   // sculpture.addIntersectSphere();
    // });

    //intersection planes
    intersectionPlanes();

    initEventHandling(); //handle mouse clicks
    requestAnimationFrame( render ); //render scene
};

function intersectionPlanes() {
    var intersect_plane = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 400, 400 ),
	new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0 , transparent: true })
    );
    intersect_plane.rotation.x = Math.PI / -2;
    scene.add( intersect_plane );

    var intersect_plane_y = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 600, 300),
	new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0 , transparent: true })
    );
    intersect_plane_y.position.set(-60,0,-35);
    intersect_plane_y.rotation.y = Math.PI/ 10;
    scene.add( intersect_plane_y );

    var intersect_plane_z = new THREE.Mesh(
    	new THREE.PlaneBufferGeometry( 600, 300),
    	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0 , transparent: true })
    );

    intersect_plane_z.rotation.y = Math.PI/ 1.9;
    intersect_plane_z.position.set(-60, 0, -35)
    scene.add( intersect_plane_z );

    intersect_planes.push(intersect_plane);
    intersect_planes.push(intersect_plane_y);
    intersect_planes.push(intersect_plane_z);
}


function Table( x,y,z, x_size, y_size, z_size, texture_path, rotation, repeat_x, repeat_z) {

    rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);
    repeat_x = typeof repeat_x !== 'undefined' ? repeat_x : 5;
    repeat_z = typeof repeat_z !== 'undefined' ? repeat_z : 5;

    var table_texture = new THREE.ImageUtils.loadTexture( texture_path );
    table_texture.wrapS = table_texture.wrapT = THREE.RepeatWrapping;
    table_texture.repeat.set( repeat_x, repeat_z );

    var table_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: table_texture, ambient: 0xFFFFFF }),
	0.8,
	0.1);

    var table = new Physijs.BoxMesh(
	new THREE.BoxGeometry( x_size, y_size, z_size ),
	table_material,
	0
    );

    table.receiveShadow = true;
    table.position.set(x,y,z);
    table.rotation.y = rotation;

    scene.add( table );
    static_surfaces.push(table);

    //return table for ad hoc fun
    return table;
};


function Wall(x,y,z,x_size,y_size,texture_path,rotation,visible) {

    rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);
    visible = typeof visible !== 'undefined' ? visible : true;

    var wall_texture = new THREE.ImageUtils.loadTexture( texture_path );
    wall_texture.wrapS = wall_texture.wrapT = THREE.RepeatWrapping;
    wall_texture.repeat.set(3,3);

    var wall_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: wall_texture, ambient: 0xFFFFFF }),
	0.8,
	0.9);

    if (!visible) wall_material = new Physijs.createMaterial(
	new THREE.MeshPhongMaterial({opacity: 0, transparent: true  }),
	0.8,
	0.9
    );

    var wall = new Physijs.BoxMesh(
	new THREE.BoxGeometry(x_size,1,y_size),
	wall_material,
	1
    );

    wall.receiveShadow = true;
    wall.castShadow = true;
    wall.position.set(x,y,z);
    wall.rotation.z = Math.PI / 2;
    wall.rotation.y = rotation;

    scene.add( wall );
    static_surfaces.push(wall);
};

//Hairball Constructor
function hairballSculpture(x,z) {

    var box_material = Physijs.createMaterial(
	new THREE.MeshLambertMaterial({ color: 0xFF66FF }),
	0.9,
	0.2);

    var box = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 10, 10, 10 ),
	box_material,
	30
    );

    box.position.set(x, -10.6, z);
    box.castShadow = true;
    box.receiveShadow = true;

    scene.add( box );
    // moveable_objects.push(box);

    box.setAngularFactor( armature_factor );
    box.setLinearFactor( armature_factor );

    var sphere_texture = THREE.ImageUtils.loadTexture('<%= asset_path 'hair.jpg' %>',THREE.SphericalRefractionMapping);
    sphere_texture.wrapS = sphere_texture.wrapT = THREE.RepeatWrapping;
    sphere_texture.repeat.set(3,3);
    
    var sphere_material = Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: sphere_texture, color: 0xffa16b, shininess: 30}),
	0.5,
	0.9);
    
    var sphere = new Physijs.SphereMesh(
	new THREE.SphereGeometry(5,20,20),
	sphere_material, 
	9
    );
    
    sphere.position.set(x, 5, z);
    sphere.castShadow = true;
    sphere.receiveShadow= true;
    scene.add( sphere );
    moveable_objects.push( sphere );

    sphere.setAngularFactor( module_factor );
    sphere.setLinearFactor( module_factor );
    
    new Sculpture(box,[sphere],1);
}
//end hairball constructor

function oliveSculpture(x,z) {
    var olives = [];
    
    var armature = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 5, 5, 5 ),
	new THREE.MeshLambertMaterial({ color: 0xEEEEEE }),
	9
    );

    armature.position.set(x,-13.75, z);
    //to match parquet floor
    armature.rotation.y = Math.PI/2;

    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
	new THREE.CylinderGeometry(0.3,0.3,45.8),
	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder.position.set(x, 5,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;
    scene.add(intersect_cylinder);

    OliveCreator(13);
    var oliveTotem = new Sculpture( armature, olives);
    
    function OliveCreator(num) {

	var olive_loader = new THREE.PLYLoader();

	// var olive_material = new Physijs.createMaterial (
	//     new THREE.MeshPhongMaterial({ color: 0x00FFFF, ambient: 0x904716}),
	//     0.5,
	//     0.5
	// );

	var olive = olive_loader.load('<%= asset_path 'ascii/Olive_nopimento.ply' %>', function( geometry ){

	    var m = new THREE.Matrix4();
	    var m1 = new THREE.Matrix4();

        // to match parquet floor
	    m.makeRotationX( 8 );//Math.PI/2 );
	    m1.makeRotationZ( 8 );//Math.PI/2 );
	    m.multiply( m1 );
	    geometry.applyMatrix(m);
	    geometry.computeBoundingBox();

	    var radius = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
	    var armature_y = -12;

        var olive_colors = [0x9F9812, 0x6D632A, 0x5A603E, 
                      0x626220, 0x5E5E3C, 0x738754, 
                      0x595A4C, 0x878032, 0x949C3E, 
                      0x69613A, 0x595532, 0xA4962E, 
                      0x605C49];

        var pimento_colors = [0xBF341F, 0xB53720, 0xC92035, 
              0xEA976F, 0xB2583E, 0xCD443A, 
              0xCC5125, 0xC2462A, 0xBB4C53, 
              0xCD444B, 0xEA6C60, 0xD5765A, 
              0xE2685D];

        // console.log(geometry);

	    for (var i = 0; i < num; i++) {

    		var y = armature_y + (olives.length * (radius));

            var olive_material = new Physijs.createMaterial (
                new THREE.MeshPhongMaterial({ color: olive_colors[i], ambient: 0x904716}),
                0.5,
                0.5
            );

    		var oliveMesh = new Physijs.CylinderMesh(
    		    geometry,
    		    olive_material,
    		    5
    		);

            // if (i == 0){
            //     console.log(geometry);
            // }
            var pimento_material = new THREE.MeshPhongMaterial({color: pimento_colors[i]});
    		
            var pimento = new THREE.Mesh(
    		    new THREE.CylinderGeometry(1.5,1.5,1.5,5),
                pimento_material
    		);

    		pimento.position.x = .25;
    		pimento.position.z = 3;
    		

    		oliveMesh.add(pimento);

    		oliveMesh.castShadow = true;
    		oliveMesh.receiveShadow = true;

    		oliveMesh.position.set(armature.position.x, y, armature.position.z);
    		oliveMesh.scale.set(0.6,0.55,0.6);

    		scene.add( oliveMesh );

    		oliveMesh.setAngularFactor( module_factor );
    		oliveMesh.setLinearFactor( module_factor );

    		//olives.push(oliveMesh);
            oliveTotem.addModule(oliveMesh);
    		moveable_objects.push(oliveMesh);
	    }
	});
    }
}

function eggSculpture(x,z) {
    var eggs = [];
    
    var armature = new Physijs.BoxMesh(
    	new THREE.BoxGeometry( 5, 1, 5 ),
    	new THREE.MeshPhongMaterial({ color: 0xEEEEEE }),
    	9
    );

    armature.position.set(x,-17, z);
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
    	new THREE.CylinderGeometry(0.25,0.25,40.8),
    	new THREE.MeshLambertMaterial()
    );

    intersect_cylinder.position.set(x,3,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;

    scene.add(intersect_cylinder);

    EggCreator(5);
    new Sculpture( armature, eggs );

    function EggCreator(num) {

    	var egg_loader = new THREE.PLYLoader();

    	var egg_material = new Physijs.createMaterial (
	    new THREE.MeshLambertMaterial({ color: 0xFFFFFF, emissive: 0x444444}),
	    0.1,
	    0.7
	);

	var egg = egg_loader.load('<%= asset_path 'ascii/Egg.ply' %>', function( geometry ){
	    
	    var m = new THREE.Matrix4();
	    var m1 = new THREE.Matrix4();
	    
	    m.makeTranslation(0,-8,0);
	    m1.makeRotationY( Math.PI/2 );
	    m.multiply(m1).multiplyScalar(0.5);
	    geometry.applyMatrix(m);
	    
	    for (var i = 0; i < num; i++){
	    	var y = 0 + (eggs.length * 12);

		
	    	var eggMesh = new Physijs.ConvexMesh(
	    		geometry,
	    		egg_material,
	    		7
	    	);


	    	eggMesh.castShadow = true;
	    	eggMesh.receiveShadow = true;
		eggMesh.position.set(armature.position.x, y, armature.position.z);
		
	    	scene.add( eggMesh );
		
		eggMesh.__dirtyRotation = true;
		eggMesh.rotation.x = Math.PI/2;
	    	if (i%2==0) eggMesh.rotation.z = Math.PI/2;
		
	    	eggMesh.setAngularFactor( module_factor );
	    	eggMesh.setLinearFactor( module_factor );

	    	eggs.push(eggMesh);
	    	moveable_objects.push(eggMesh);
	    }
	});
    }
}

//circle centered on x,z
function TongueSculpture(x,z) {

    var geometries = this;
    var geometry = geometries[0];
    // geometry.computeBoundingBox();
    // geometry.computeBoundingSphere();

    // if we want to use this x and z then we'll need to save ply geometries globally
    if (typeof x === 'undefined') { x = 2; }
    if (typeof z === 'undefined') { z = 10; }

    // var tongues = [];
    // var armature = new Physijs.BoxMesh(
    //     new THREE.BoxGeometry( 5, 1, 5 ),
    //     new THREE.MeshPhongMaterial({ color: 0xEEEEEE }),
    //     9
    // );

    // armature.position.set(x,-17.5 , z);
    // armature.castShadow = true;
    // armature.receiveShadow= true;

    // scene.add( armature );

    var num = 9;

    var tongueMaterial = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xff7fb6 }),
        0.1,
        0.7);
    
    var m = new THREE.Matrix4();
    var m1 = new THREE.Matrix4();
    // var m2 = new THREE.Matrix4();

    m.scale(new THREE.Vector3(1.5,1.5,1.5));        
    // m.makeTranslation(0,-8,0);
    // m.makeRotationX( -Math.PI/4 );
    m1.makeRotationX( Math.PI/2 );
    // m2.makeRotationY( Math.PI/2 );

    m.multiply(m1);
    geometry.applyMatrix(m);
        
    var r = 15;

    var arm_geo = new THREE.CylinderGeometry( .3, .3, 1.5, 5 );
    // var interSphere = new THREE.SphereGeometry( 5, 5, 5);
    
    for (var i = 0; i < num; i++){
        var tongues = [];

        var rebar = new THREE.Mesh(
            arm_geo,
            new THREE.MeshPhongMaterial({ color: 0x664935 })
        );

        rebar.geometry.computeBoundingBox();
        rebar.geometry.computeBoundingSphere();

        rebar.castShadow = true;
        rebar.receiveShadow= true;

        var tongueSculpture = new Sculpture( rebar, tongues);

        var rotX = new THREE.Matrix4();
        rotX.makeRotationX(-Math.PI/2);

        rebar.geometry.applyMatrix(rotX);

        var a = (2 * Math.PI / num) * i;

        var rotY = new THREE.Matrix4();
        rotY.makeRotationY(a);
        geometry.applyMatrix(rotY);
        rebar.geometry.applyMatrix(rotY);


        var tongueMesh = new Physijs.ConvexMesh(
            geometry,
            tongueMaterial,
            7
        );
        tongueMesh.geometry.computeBoundingBox();
        tongueMesh.geometry.computeBoundingSphere();
        tongueMesh.castShadow = true;
        tongueMesh.receiveShadow = true;

        //x = cx + r * cos(a)
        //y = cy + r * sin(a)
        var xC = x + r * Math.cos(a);
        var zC = z + r * Math.sin(a);

        rebar.position.set(xC , -17, zC);

        tongueMesh.rotation.y = -a;
        rebar.rotation.y = -a;

        scene.add( tongueMesh );
        scene.add( rebar );
    
        tongueMesh.__dirtyRotation = true;
    
        tongueMesh.setAngularFactor( module_factor );
        tongueMesh.setLinearFactor( module_factor );

        moveable_objects.push(tongueMesh);

        tongueSculpture.addModule(tongueMesh);

        var y =  i * 6 + 5;  
        tongueMesh.position.y = y;
    }

}

function wedgeSculpture(x, z) {
    var geometries = this;
    //console.log(geometries);
    // if we want to use this x and z then we'll need to save ply geometries globally
    if (typeof x === 'undefined') { x = -50; }
    if (typeof z === 'undefined') { z = -40; }

    var wedges = [];

    // In the future, custom armature geometry could be geometries[0]
    var armature_mat = new THREE.MeshPhongMaterial({ color: 0x664935 });

    var armature = new Physijs.BoxMesh(    
    new THREE.BoxGeometry( 24, 1, 24 ),
        armature_mat,
        .9,
        .9
    );

    armature.position.set(x, -16, z);
    
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder_one = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25,0.25,65),
        armature_mat
    );

    intersect_cylinder_one.position.set(x + .75 ,3 , z - .75);
    intersect_cylinder_one.castShadow = true;
    intersect_cylinder_one.receiveShadow = true;

    var intersect_cylinder_two = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25,0.25,65),
        armature_mat
    );

    intersect_cylinder_two.position.set(x - .75 ,3 ,z + .75);
    intersect_cylinder_two.castShadow = true;
    intersect_cylinder_two.receiveShadow = true;

    scene.add(intersect_cylinder_one);
    scene.add(intersect_cylinder_two);

    //num = 47

    var wedge_material = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xDDDDDD }),
        1,
        1
    );

    var long_wedge_mat = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xFF5934 }),
        1,
        1
    );

    var geometry_flat = geometries[0];
    var geometry_hammer = geometries[1];

    var m = new THREE.Matrix4();
    var m3 = new THREE.Matrix4();
    var geo_flat_left = geometry_flat.clone();
    m.makeRotationY( Math.PI );        
    geometry_flat.applyMatrix(m);

    var geo_hammer_left = geometry_hammer.clone();
    m.makeRotationY( Math.PI );        
    geometry_hammer.applyMatrix(m);


    var mX = new THREE.Matrix4();
    // var mY = new THREE.Matrix4();
    // mY.makeRotationX(Math.PI/4);
    var mY = new THREE.Matrix4();
    mY.makeRotationY(Math.PI/1.1);
    mX.makeRotationX(Math.PI/2);

    mY.multiply(mX);
    // mX.multiply(mZ);
    var longWedge_one = geometries[2];
    longWedge_one.applyMatrix(mY);
    // var longWedge_one = new THREE.Geometry();
    
    // var faces = geometries[2].faces.concat(geometries[3].faces);
    // var vertices = geometries[2].vertices.concat(geometries[3].vertices);
    
    // longWedge_one.vertices = vertices;
    // longWedge_one.faces = faces;

    // for (var i = 0; i < geometries[2].vertices.length; i++){
    //     longWedge_one.vertices.push(geometries[2].vertices[i]);
    // } 
    // for (var i = 0; i < geometries[2].faces.length; i++){
    //     longWedge_one.faces.push(geometries[2].faces[i]);
    // } 
    // for (var i = 0; i < geometries[3].vertices.length; i++){
    //     longWedge_one.vertices.push(geometries[3].vertices[i]);
    // }     



    // for (var i = 0; i < geometries[3].faces.length; i++){
    //     longWedge_one.faces.push(geometries[3].faces[i]);
    // } 

    longWedge_one.computeBoundingSphere();
    // var verts = [];
    // verts = longWedge_one.vertices.concat(geometries[3].vertices);
    // longWedge_one.vertices = verts;
    // for (var i = 0; i < geometries[2].vertices.length; i++){
    //     // longWedge_one.__dirtyVertices = true;
    //     longWedge_one.vertices.push(geometries[3].vertices[i]);
    // }            
    // longWedge_one.verticesNeedUpdate = true;
    
    // geo_longWedge.applyMatrix(mX);

    //var yFactor = geometry_flat.boundingSphere.radius;
    var wedge_models = [geometry_flat, geo_flat_left, geometry_hammer, geo_hammer_left, longWedge_one];
    
    var arrangement = [3, 3, 3, 3,
                        3, 0, 0, 0,
                        0, 0, 0, 3,
                        3, 3, 3, 3,
                        3, 0, 0, 0, 
                        0, 0, 0,
                        3, 3, 3, 4,
                        3, 3, 3, 3,
                        0, 0, 0, 0,
                        3, 3, 3, 3,
                        0, 0, 0, 0];
    
    var wedge_stack = new Sculpture( armature, wedges, arrangement.length + 1);
    
    geometry_flat.computeBoundingBox();

    var r = .6;//(geometry_flat.boundingBox.max.y - geometry_flat.boundingBox.min.y) / 2;

    //Sculpture starts with one rectangular module
    var blockMesh = new Physijs.BoxMesh(
        new THREE.BoxGeometry(4, 1.25, 2),
        wedge_material,
        30
    );

    blockMesh.rotation.y = Math.PI / 4;
    
    blockMesh.castShadow = true;
    blockMesh.receiveShadow = true;

    scene.add( blockMesh );

    _v3 = new THREE.Vector3(0,0,0);
    
    blockMesh.setAngularFactor( _v3 ); 
    blockMesh.setAngularVelocity(_v3);

    blockMesh.setLinearFactor( module_factor );
    blockMesh.setLinearVelocity(_v3);

    moveable_objects.push( blockMesh );
    wedge_stack.addModule(blockMesh);


    for (var i = 0; i < arrangement.length; i++){

        var wMat;
        if (arrangement[i] == 4) {
            wMat = long_wedge_mat;
            var wedgeMesh = new Physijs.ConvexMesh(
                wedge_models[arrangement[i]],
                wMat,
                30
            );
        }
        else { 
            wMat = wedge_material; 
            var wedgeMesh = new Physijs.ConvexMesh(
                wedge_models[arrangement[i]],
                wMat,
                30
            );
        }

        // var wedgeMesh = new Physijs.ConvexMesh(
        //     wedge_models[arrangement[i]],
        //     wMat,
        //     30
        // );

        // wedgeMesh.setCcdMotionThreshold(1);

        var y = (wedges.length * r) - 6;

        wedgeMesh.castShadow = true;
        wedgeMesh.receiveShadow = true;
        // wedgeMesh.position.set(armature.position.x, y, armature.position.z);

        // wedgeMesh.__dirtyRotation = true;

        scene.add( wedgeMesh );

        // _v3 = new THREE.Vector3(0,0,0);
        
        wedgeMesh.setAngularFactor( _v3 ); 
        wedgeMesh.setAngularVelocity(_v3);
// previously had been: new THREE.Vector3( 0 , 0 , 0);
        wedgeMesh.setLinearFactor( module_factor );
        wedgeMesh.setLinearVelocity(_v3);


        // wedges.push( wedgeMesh );
        moveable_objects.push( wedgeMesh );
        wedge_stack.addModule(wedgeMesh);


    }
}

// relates armature and modules
// idea for the future: add moduleVector to the constructor
var Sculpture = function( armature, modules, limit ) {
    this.armature = armature;
    this.modules = modules;
    this.limit = limit || 50;
    //this.intersect_sphere;

    // add scupture object to array of sculptures
    sculptures.push(this);
};

Sculpture.prototype.removeModule = function( obj ) {
	this.modules.splice( this.modules.indexOf(obj), 1 );
	// if (this.modules.length == 0) {
	// 	moveable_objects.push(this.armature);
	// 	this.limit = 0;		
	// }
};


Sculpture.prototype.addModule = function( obj ) {
    var snap_y;
    if (!this.isAtLimit()) {
    	
        var r = (obj.geometry.boundingBox.max.y - obj.geometry.boundingBox.min.y) / 2;
        
        if (this.modules.length == 0) {
    	    snap_y = -6
    		+ this.armature.geometry.boundingBox.max.y
    		+ r;
    	}
    	
        else {
    	    snap_y = this.modules[this.modules.length-1].position.y
    		+ this.modules[this.modules.length-1].geometry.boundingBox.max.y
    		+ r;
    	}

    	//put object in position
    	obj.position.set( this.armature.position.x,
    			  snap_y,
    			  this.armature.position.z );

    	//make object static
        obj.setDamping(.9,.9);

    	_v3 = new THREE.Vector3(0,1,0);
    	obj.setLinearFactor(_v3);

    	_v3 = new THREE.Vector3(0,0,0);
    	obj.setLinearVelocity(_v3);
        obj.setAngularFactor(_v3);
        
        obj.__dirtyPosition = true;
        obj.__dirtyRotation = true;

    	//finally, push selected_thing on the sculpture stack
    	this.modules.push( obj );
    }
};

Sculpture.prototype.isAtLimit = function() {
    return ( this.modules.length >= this.limit ) ? true : false;
};

Sculpture.prototype.addIntersectSphere = function() {
    // this.intersect_sphere = new THREE.Mesh(
    // 	new THREE.SphereGeometry( 10 ),
    // 	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 1 , transparent: true })
    // );
    
    // if (modules.length > 0) {
    // 	this.intersect_sphere.position.copy(this.modules[this.modules.length-1].position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // else {
    // 	this.intersect_sphere.position.copy(this.armature.position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // scene.add(this.intersect_sphere);

}

// Load ply objects asynchronously, calls sculpture function afterwards
// Takes asset paths as array of strings and callback function as arguments
// The arguments look like (['<%= asset_path 'ascii/Wedge_Flat.ply' %>', '<%= asset_path 'ascii/Wedge_Hammerhead.ply' %>'], wedgeSculpture)
// The function returns an array [geometry1, geometry2], accessed in callback function with keyword this
function LoadPlyAssets( assetPathArray, callback ){
    //console.log("loadPlyAssets");

    // array of returned geometries
    var geometries = [];//new Array(assetPathArray.length);

    for (var i = 0; i < assetPathArray.length; i++) {
        var geometry_loader = new THREE.PLYLoader();

        var geo = geometry_loader.load( assetPathArray[i], function( geometry ){
            // Problem: right now can't make sure that the first asset goes in geometries[0]
            
            geometries.push( geometry );

            if ( geometries.length == assetPathArray.length ){
                //console.log(geometries);
                callback.call( geometries );
            }
        });
    }
}


//user input
initEventHandling = (function() {
    var handleMouseDown, handleMouseMove, handleMouseUp, handleKeyDown, handleResize;
    var raycaster = new THREE.Raycaster();
    var thing_offset = new THREE.Vector3;
    var _vector = new THREE.Vector3();
    var sculpture, collisionResults, intersections, intersection;
    var spot_light_on = false;

    handleResize = function( evt ) {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
    };

    handleMouseDown = function( evt ) {


	_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
		    -(evt.clientY / window.innerHeight ) * 2 + 1,
		    1);

	raycaster.setFromCamera(_vector, camera);
	intersections = raycaster.intersectObjects( moveable_objects );

	if (intersections.length > 0) {
	    selected_thing = intersections[0].object;

	    // if it is on a sculpture, pop it and make it dynamic
	    for (i = 0; i < sculptures.length; i++) {
		  if (sculptures[i].modules.indexOf(selected_thing) >= 0) {
		    sculptures[i].removeModule(selected_thing);
		    break;
		  }
	    }


	    _vector.set(0,0,0);
	    selected_thing.setAngularFactor( _vector);
	    selected_thing.setAngularVelocity( _vector);
	    selected_thing.setLinearFactor( _vector);
	    selected_thing.setLinearVelocity( _vector);

	    mouse_position.copy(intersections[0].point);
	    thing_offset.subVectors( selected_thing.position, mouse_position);

	}
	// else {
	//     intersections = raycaster.intersectObjects( static_surfaces );
	//     if (intersections.length > 0) {
	// 	for (var i = 0; i < moveable_objects.length; i++) {
	// 	    _v3 = moveable_objects[i].getLinearVelocity();
	// 	    if (Math.abs(_v3.y) < 2 ) moveable_objects[i].applyCentralImpulse(new THREE.Vector3(0,50,0));
	// 	}
	//     }
	// }

    };

    handleMouseMove = function( evt ) {
        //console.log(-1);
        _vector.set(
        ( evt.clientX / window.innerWidth ) * 2 - 1,
        -( evt.clientY / window.innerHeight ) * 2 + 1,
        1);

        raycaster.setFromCamera(_vector, camera);

    	if (selected_thing !== null) {


    	    intersection = raycaster.intersectObjects( intersect_planes );
    	    if ( intersection[0] != undefined) {
    		  mouse_position.copy(intersection[0].point);
    	    }

    	    //iterates through sculpture objects
    	    for (i = 0; i < sculptures.length; i++) {
    		    collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
    		    if (collisionResults.length !== 0 && !sculptures[i].isAtLimit()) {
                    // shouldn't need this
                    // if (collisionResults[0].object == selected_thing) {
                    //     continue;
                    // }

        		    sculpture = sculptures[i];
        		    
        		    //make a light source directly above the sculpture
        		    spot_light.position.set( sculpture.armature.position.x, spot_light.position.y, sculpture.armature.position.z );
        		    spot_light.target = sculpture.armature;
        		    spot_light.intensity = 6;
        		    spot_light_on = true;
        		    
        		    break;
    		    }
        		else if ( spot_light_on ) { //if the light source is on
        		    spot_light.intensity = 0;
        		}
    	    }
    	}
        //jiggle
        // else {
        //     _vector.set(
        //     ( evt.clientX / window.innerWidth ) * 2 - 1,
        //         -( evt.clientY / window.innerHeight ) * 2 + 1,
        //     1);

        //     raycaster.setFromCamera(_vector, camera);
            
        //     intersection = raycaster.intersectObjects(moveable_objects);

        //     if ( intersection[0] != undefined) {
        //         var vl = intersection[0].object.getLinearVelocity().clone();
        //         var va = intersection[0].object.getAngularVelocity().clone();
                
        //         va.multiplyScalar(-1).add(new THREE.Vector3(Math.random(), 2 * Math.random(), 0));
        //         vl.multiplyScalar(-1).add(new THREE.Vector3(5 * Math.random(), 5 * Math.random()));
        //         intersection[0].object.setLinearVelocity(vl);
        //         intersection[0].object.setAngularVelocity(va);
                
        //     }

        // }
        // pointer
        else {
            // _vector.set(
            //     ( evt.clientX / window.innerWidth ) * 2 - 1,
            //     -( evt.clientY / window.innerHeight ) * 2 + 1,
            //     1 );

            // raycaster.setFromCamera(_vector, camera);
            
            intersection = raycaster.intersectObjects(moveable_objects);

            if ( intersection[0] != undefined) {
                renderer.domElement.style.cursor = "pointer";
            }
            else renderer.domElement.style.cursor = "default";


        }
    };

    handleMouseUp = function( evt ) {

	if (selected_thing !== null) {

	    _vector.set(1,1,1);
	    selected_thing.setAngularFactor( _vector );
	    selected_thing.setLinearFactor( _vector );

	    // snapping to armature
		_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
			-(evt.clientY / window.innerHeight ) * 2 + 1,
			1);

	    raycaster.setFromCamera(_vector, camera);

	    //iterates through sculpture objects
	    for (i = 0; i < sculptures.length; i++) {
		collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
		if (collisionResults.length !== 0) {
		    sculpture = sculptures[i];
		    break;
		}
	    }

	    if ( collisionResults.length !== 0) {

		sculpture.addModule( selected_thing );

		//turn off spotlight
		spot_light.intensity = 0;


	    }
	    //end snapping

	    selected_thing = null;
	}
    };

    //rotate camera
    handleKeyDown =  function( evt ){

	var x = camera.position.x,
	    y = camera.position.y,
	    z = camera.position.z;
	var rotSpeed = 0.05;

	if (evt.keyCode=="37"){
	    camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
	    camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
	}

	else if (evt.keyCode=="39"){
	    camera.position.x = x * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
	    camera.position.z = z * Math.cos(rotSpeed) + x * Math.sin(rotSpeed);
	}

	camera.lookAt(scene.position);

    }

    return function() {
	renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
	renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
	renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
	renderer.domElement.addEventListener( 'keydown', handleKeyDown );
	window.addEventListener('resize', handleResize );
    };
})();

//render loop
render = function() {
    scene.simulate(); // run physics
    renderer.render( scene, camera); // render the scene
    requestAnimationFrame( render );
};

initScene();
</script>
    
