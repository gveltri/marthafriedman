<!-- For the Future
1) Load PLY objects as binary
2) Bring soft body action from Ammo through Physijs and THREE
-->
<script>
    Physijs.scripts.worker = '<%= asset_path 'physijs_worker.js' %>';
    Physijs.scripts.ammo = 'https://raw.githubusercontent.com/gveltri/marthafriedman/galleryChanges/app/assets/javascripts/ammo.js';

var initScene, render, renderer, scene, camera, initEventHandling;

var fill, backlight, am_light, spot_light, spot_light2, point_light;

var moveable_objects = [], selected_thing = null, static_surfaces=[],
    intersect_planes = [], sculptures=[];

var mouse_position = new THREE.Vector3, _v3 = new THREE.Vector3,
    module_factor = new THREE.Vector3( 0, 0.5, 0 ), armature_factor = new THREE.Vector3( 0, 0, 0 );

var cameraTarget = new THREE.Vector3; var factor = .0067;

initScene = function() {
    renderer = new THREE.WebGLRenderer({ antialias : true }); //alpha: true
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFSoftShadowMap;
    renderer.shadowMapAutoUpdate = true;
    renderer.setClearColor( 0xece7eb, 0 );

    document.getElementById('container').appendChild(renderer.domElement);
    //allows keydown to be heard
    renderer.domElement.setAttribute("tabindex", 0);

    renderer.sortObjects = true;

    // Initialize Physijs Scene
    scene = new Physijs.Scene();
    scene.setGravity( new THREE.Vector3(0, -120, 0) );

    // Click-and-drag functionality
    scene.addEventListener( 'update', function() {
	if ( selected_thing !== null ) {
	    _v3.copy( mouse_position ).sub( selected_thing.position ).multiplyScalar( 5 );
	    selected_thing.setLinearVelocity( _v3 );
	    _v3.set( 0, 0, 0 );
	    for ( _i = 0; _i < moveable_objects.length; _i++ ) {
		moveable_objects[_i].applyCentralImpulse( _v3 );
	    }
	}
	scene.simulate( undefined, 1 );
    });

    // camera
    camera = new THREE.PerspectiveCamera(
    	35,
    	window.innerWidth / window.innerHeight,
    	    1,
    	1000
    );
    camera.position.set(120,50,90);
    camera.position.x = camera.position.x * Math.cos(.2) + camera.position.z * Math.sin(.2);
    camera.position.z = camera.position.z * Math.cos(.2) - camera.position.x * Math.sin(.2);
    camera.lookAt(scene.position);
    // cameraTarget = scene.position.clone();


    //ambient light
    am_light = new THREE.AmbientLight( 0x040404 );
    scene.add( am_light );

    //point light
    // point_light = new THREE.PointLight( 0xFFFFFF, 0.5, 100 );
    // point_light.position.set( -15, 20, -30 );
    // scene.add( point_light );

    // var pointhelper = new THREE.PointLightHelper(point_light, 1);
    // scene.add(pointhelper);

    // directional lights
    fill = new THREE.DirectionalLight( 0x202020, 10 );
    fill.position.set( 40, 45, 70 );
    fill.target.position.copy( scene.position );
    fill.castShadow = true;
    fill.shadowCameraLeft = -100;
    fill.shadowCameraTop = -100;
    fill.shadowCameraRight = 100;
    fill.shadowCameraBottom = 100;
    fill.shadowCameraNear = 0;
    fill.shadowCameraFar = 200;
    // fill.shadowCameraVisible = true;
    // fill.shadowBias = .001
    fill.shadowMapWidth = fill.shadowMapHeight = 4096;
    fill.shadowDarkness = .3;

    scene.add( fill );

    // var fillhelper = new THREE.DirectionalLightHelper(fill, 25);
    // scene.add(fillhelper);

    backlight = new THREE.DirectionalLight( 0x4F4040);
    backlight.position.set( -200, 20, -50 );
    backlight.target.position.copy( scene.position );
    backlight.castShadow = true;
    backlight.shadowCameraLeft = -150;
    backlight.shadowCameraTop = -150;
    backlight.shadowCameraRight = 150;
    backlight.shadowCameraBottom = 150;
    backlight.shadowCameraNear = 0;
    backlight.shadowCameraFar = 100;
    // backlight.shadowBias = .001
    // backlight.shadowCameraVisible = true;
    backlight.shadowMapWidth = backlight.shadowMapHeight = 4096;
    backlight.shadowDarkness = .3;
    backlight.intensity = 8;

    scene.add( backlight );

    // var hemLight = new THREE.HemisphereLight(0x4F4040, 0xd4e2f9, .3);
    // scene.add(hemLight);


    spot_light = new THREE.SpotLight( 0xf3f9de, 0, 150, Math.PI/8, 65, .1 );
    spot_light.position.set( 50, 40, 20);
    // spot_light.position.set( camera.position );
    spot_light.intensity = 0;
    spot_light.castShadow = true;
    spot_light.shadowBias = 0;
    spot_light.shadowMapWidth = spot_light.shadowMapHeight = 4096;
    // spot_light.target = scene;
    // spot_light.shadowCameraVisible = true;
    spot_light.shadowCameraNear = 1;
    // spot_light.shadowCameraFar = 300;
    spot_light.shadowCameraFov = 600;
        // spot_light.shadowCameraRight = 150;
    // spot_light.shadowCameraBottom = 150;
    scene.add(spot_light);


    // console.log(spot_light);
    // spot_light.shadowCamera.updateProjectionMatrix();
    // spot_light.shadowCameraRight = 150;
    // spot_light.shadowCameraBottom = 150;

    // spot_light.target = scene;
    // spot_light.visible = false;
    // scene.add(spot_light);
    // spot_light.intensity = 0;

    // var spothelper = new THREE.SpotLightHelper(spot_light);
    // scene.add(spothelper);
    

    //space init

    // make less heavy
    Table( 0, -18, -40, 50, 3, 50, '<%= asset_path 'parquet_2.jpg' %>', Math.PI / 2, 8, 8 );    
    Table( -50, -17.25, -15, 50, 3, 100, '<%= asset_path 'concrete_1.jpg' %>', 0, 5, 17);
    Table( -25, -19.25, -15, 100, 2, 100,'<%= asset_path 'grass.jpg' %>', Math.PI / 2, 3, 3);

	//sculptures init
     
    var oliveAssets = ['<%= asset_path 'binary/Olive_nopimento.ply' %>'];
    LoadPlyAssets(oliveAssets, oliveSculpture);

    hairballSculpture(-50, 20);
    eggSculpture(-50,-5);

    // New way to make a sculptures
    var wedgeAssets = ['<%= asset_path 'binary/WedgeDroop.ply' %>', '<%= asset_path 'binary/Wedge_Flat.ply' %>', '<%= asset_path 'binary/Wedge_Hammerhead.ply' %>'];
    LoadPlyAssets(wedgeAssets, wedgeSculpture);    // default x: -50 , z: -40

    var tongueAssets = ['<%= asset_path 'binary/Tongue_up2.ply' %>'];
    LoadPlyAssets(tongueAssets, TongueSculpture); 

    //intersection planes
    intersectionPlanes();

    initEventHandling(); //handle mouse clicks
    requestAnimationFrame( render ); //render scene
};

function intersectionPlanes() {
    var intersect_plane = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 400, 400 ),
	new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0 , transparent: true })
    );
    intersect_plane.rotation.x = Math.PI / -2;
    scene.add( intersect_plane );

    var intersect_plane_y = new THREE.Mesh(
	new THREE.PlaneBufferGeometry( 600, 300),
	new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0 , transparent: true })
    );
    intersect_plane_y.position.set(-60,0,-35);
    intersect_plane_y.rotation.y = Math.PI/ 10;
    scene.add( intersect_plane_y );

    var intersect_plane_z = new THREE.Mesh(
    	new THREE.PlaneBufferGeometry( 600, 300),
    	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0 , transparent: true })
    );

    intersect_plane_z.rotation.y = Math.PI/ 1.9;
    intersect_plane_z.position.set(-60, 0, -35)
    scene.add( intersect_plane_z );

    intersect_planes.push(intersect_plane);
    intersect_planes.push(intersect_plane_y);
    intersect_planes.push(intersect_plane_z);
}


function Table( x,y,z, x_size, y_size, z_size, texture_path, rotation, repeat_x, repeat_z) {

    rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);
    repeat_x = typeof repeat_x !== 'undefined' ? repeat_x : 5;
    repeat_z = typeof repeat_z !== 'undefined' ? repeat_z : 5;

    var table_texture = new THREE.ImageUtils.loadTexture( texture_path );

    table_texture.wrapS = table_texture.wrapT = THREE.RepeatWrapping;
    table_texture.repeat.set( repeat_x, repeat_z );

    var table_material = new Physijs.createMaterial(
	   new THREE.MeshPhongMaterial({ map: table_texture, ambient: 0xFFFFFF }),
	   0.9,
	   0.9);

    var table = new Physijs.BoxMesh(
	new THREE.BoxGeometry( x_size, y_size, z_size ),
	table_material,
	10
    );

    table.receiveShadow = true;
    table.position.set(x,y,z);
    table.rotation.y = rotation;

    scene.add( table );


    table.setAngularFactor(armature_factor);
    table.setLinearFactor(armature_factor);
    
    static_surfaces.push(table);

    //return table for ad hoc fun
    return table;
};


// function Wall(x,y,z,x_size,y_size,texture_path,rotation,visible) {

//     rotation = typeof rotation !== 'undefined' ? rotation : (-Math.PI / 4);
//     visible = typeof visible !== 'undefined' ? visible : true;

//     var wall_texture = new THREE.ImageUtils.loadTexture( texture_path );
//     wall_texture.wrapS = wall_texture.wrapT = THREE.RepeatWrapping;
//     wall_texture.repeat.set(3,3);

//     var wall_material = new Physijs.createMaterial(
// 	new THREE.MeshPhongMaterial({ map: wall_texture, ambient: 0xFFFFFF }),
// 	0.8,
// 	0.9);

//     if (!visible) wall_material = new Physijs.createMaterial(
// 	new THREE.MeshPhongMaterial({opacity: 0, transparent: true  }),
// 	0.8,
// 	0.9
//     );

//     var wall = new Physijs.BoxMesh(
// 	new THREE.BoxGeometry(x_size,1,y_size),
// 	wall_material,
// 	1
//     );

//     wall.receiveShadow = true;
//     wall.castShadow = true;
//     wall.position.set(x,y,z);
//     wall.rotation.z = Math.PI / 2;
//     wall.rotation.y = rotation;

//     scene.add( wall );
//     static_surfaces.push(wall);
// };

//Hairball Constructor
function hairballSculpture(x,z) {

    var box_material = Physijs.createMaterial(
	new THREE.MeshLambertMaterial({ color: 0xFF66FF }),
	0.9,
	0.2);

    var box = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 10, 10, 10 ),
	box_material,
	30
    );

    box.position.set(x, -10.6, z);
    box.castShadow = true;
    box.receiveShadow = true;

    scene.add( box );
    moveable_objects.push(box);

    box.setAngularFactor( armature_factor );
    box.setLinearFactor( armature_factor );

    var sphere_texture = THREE.ImageUtils.loadTexture('<%= asset_path 'hair.jpg' %>',THREE.SphericalRefractionMapping);
    sphere_texture.wrapS = sphere_texture.wrapT = THREE.RepeatWrapping;
    sphere_texture.repeat.set(3,3);
    
    var sphere_material = Physijs.createMaterial(
	new THREE.MeshPhongMaterial({ map: sphere_texture, color: 0xffa16b, shininess: 30}),
	0.5,
	0.9);
    
    var sphere = new Physijs.SphereMesh(
	new THREE.SphereGeometry(5,20,20),
	sphere_material, 
	9
    );
    
    sphere.position.set(x, 5, z);
    sphere.castShadow = true;
    sphere.receiveShadow= true;
    scene.add( sphere );
    moveable_objects.push( sphere );

    sphere.setAngularFactor( module_factor );
    sphere.setLinearFactor( module_factor );
    
    new Sculpture(box,[sphere],1);
}
//end hairball constructor

function oliveSculpture(x, z) {
    var geometries = this;
    var geometry = geometries[0];

    if (typeof x === 'undefined') { x = 0; }
    if (typeof z === 'undefined') { z = -40; }

    
    var armature = new Physijs.BoxMesh(
	new THREE.BoxGeometry( 4, 2.5, 3 ),
	new THREE.MeshLambertMaterial({ color: 0xEEEEEE }),
	9
    );

    armature.position.set(x,-15.5, z);
    //console.log(armature.position);
    //to match parquet floor
    armature.rotation.y = Math.PI/2;

    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
	   new THREE.CylinderGeometry(0.3,0.3,40),
	   new THREE.MeshPhongMaterial({ color: 0x664935 })
    );

    intersect_cylinder.position.set(x, 5,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;
    scene.add(intersect_cylinder);

    var num = 13;

    var olives = [];
    var oliveTotem = new Sculpture( armature, olives);

    var m = new THREE.Matrix4();
    var m1 = new THREE.Matrix4();

    // to match parquet floor
    m.makeRotationX( Math.PI/2 );
    m1.makeRotationZ( Math.PI/2 );
    m.multiply( m1 );
    geometry.applyMatrix(m);
    geometry.computeBoundingBox();

    var radius = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
    var armature_y = -12;

    var uniforms = THREE.UniformsUtils.merge(
        [THREE.UniformsLib['lights'],
        {
          diffuse: {type: 'c', value: new THREE.Color(0x0000ff)},
          steps: {type: 'f', value: 4}
        }
        ]
    )
    var vertexShader = document.getElementById('vertexShader').text;
    var fragmentShader = document.getElementById('fragmentShader').text;

    var material = new THREE.ShaderMaterial(
        {
          uniforms : uniforms,
          vertexShader : vertexShader,
          fragmentShader : fragmentShader,
          lights: true
        });

    var olive_colors = [0x9F9812, 0x6D632A, 0x5A603E, 
                0x626220, 0x5E5E3C, 0x738754, 
                0x595A4C, 0x878032, 0x949C3E, 
                0x69613A, 0x595532, 0xA4962E, 
                0x605C49, 0x605C49];

    var pimento_colors = [0xBF341F, 0xB53720, 0xC92035, 
                0xEA976F, 0xB2583E, 0xCD443A, 
                0xCC5125, 0xC2462A, 0xBB4C53, 
                0xCD444B, 0xEA6C60, 0xD5765A, 
                0xE2685D, 0xC92035];
    
    // geometry.computeVertexNormals();
    // geometry.computeFaceNormals();
    // assignUVs(geometry);
    computeFlipNormals(geometry);
    
    // plus one for extra olive
    for (var i = 0; i < num + 1; i++) {

		// // var y = armature_y + (olives.length * (radius));

        // var olive_material = new Physijs.createMaterial (
        //     new THREE.MeshPhongMaterial({ color: olive_colors[i] }),
        //     0.5
        // );

        var olive_material = new THREE.MeshPhongMaterial({color: olive_colors[i]});

		var oliveMesh = new Physijs.CylinderMesh(
		    geometry,
		    // new THREE.CylinderGeometry(3,3,3,10),
            olive_material,
            // material,
		    5
		);

        //suggested by, doesn't seem necessary lol
        //http://stackoverflow.com/questions/11032145/three-js-custom-objloader-geometry-lighting
        // oliveMesh.flipSided = true;
        // oliveMesh.doubleSided = true;


        var pimento_material = new THREE.MeshPhongMaterial({color: pimento_colors[i]});
		
        var pimento = new THREE.Mesh(
		    new THREE.CylinderGeometry(1.5,1.5,1.5,5),
            pimento_material
		);

		pimento.position.x = .25;
		pimento.position.z = 3;
		
		oliveMesh.add(pimento);

        pimento.castShadow = true;
        pimento.receiveShadow = true;

		oliveMesh.castShadow = true;
		oliveMesh.receiveShadow = true;

		oliveMesh.scale.set(0.6,0.55,0.6);

		scene.add( oliveMesh );

        moveable_objects.push(oliveMesh);
        
        if (i == num ){
            oliveMesh.position.set(x + .5, 95, z + .5);
            oliveMesh.__dirtyPosition = true;
            oliveMesh.__dirtyRotation = true;

            // oliveMesh.setCcdMotionThreshold(.075);
            // oliveMesh.setCcdSweptSphereRadius(.15);
 
            continue;
        }   

        oliveTotem.addModule(oliveMesh);

        }
}

function eggSculpture(x,z) {
    var eggs = [];
    
    var armature = new Physijs.BoxMesh(
    	new THREE.BoxGeometry( 5, 1, 5 ),
    	new THREE.MeshPhongMaterial({ color: 0x664935 }),
    	9
    );

    armature.position.set(x,-17, z);
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder = new THREE.Mesh(
    	new THREE.CylinderGeometry(0.25,0.25,60),
    	new THREE.MeshPhongMaterial({ color: 0x664935 })
    );

    intersect_cylinder.position.set(x,3,z);
    intersect_cylinder.castShadow = true;
    intersect_cylinder.receiveShadow = true;

    scene.add(intersect_cylinder);

    EggCreator(5);
    var eggSculpture = new Sculpture( armature, eggs );

    function EggCreator(num) {

    	var egg_loader = new THREE.PLYLoader();

    	var egg_material = new Physijs.createMaterial (
	    new THREE.MeshLambertMaterial({ color: 0xf8f9e7, ambient: 0xFFFFFF}),
	    0.1,
	    0.7
	);

	var egg = egg_loader.load('<%= asset_path 'binary/Egg.ply' %>', function( geometry ){
        computeFlipNormals(geometry);

	    var m = new THREE.Matrix4();
	    var m1 = new THREE.Matrix4();
	    
	    m.makeTranslation(0,-8,0);
	    m1.makeRotationY( Math.PI/2 );
	    m.multiply(m1).multiplyScalar(0.7);
	    geometry.applyMatrix(m);
	    
	    for (var i = 0; i < num; i++){
	    	var y = 0 + (eggs.length * 12);

		
	    	var eggMesh = new Physijs.ConvexMesh(
	    		geometry,
	    		egg_material,
	    		7
	    	);


	    	eggMesh.castShadow = true;
	    	eggMesh.receiveShadow = true;
		    eggMesh.position.set(armature.position.x, y, armature.position.z);
		
	    	scene.add( eggMesh );
		
		    eggMesh.rotation.x = Math.PI/2;
	    	
            if ( i % 2 == 0 ) {
                eggMesh.rotation.z = Math.PI/2;
            }

            eggMesh.__dirtyRotation = true;
		
	    	// eggMesh.setLinearFactor( module_factor );

	    	// eggs.push(eggMesh);
            eggSculpture.addModule(eggMesh);

	    	moveable_objects.push(eggMesh);
	    }
	});
    }
}

//circle centered on x,z
function TongueSculpture(x,z) {

    var geometries = this;
    var geometry = geometries[0];
    // geometry.computeBoundingBox();
    // geometry.computeBoundingSphere();

    // if we want to use this x and z then we'll need to save ply geometries globally
    if (typeof x === 'undefined') { x = 2; }
    if (typeof z === 'undefined') { z = 10; }

    var num = 9;

    var tongueMaterial = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xff729a, shininess: 45/*0xff7fb6*/ }),
        0.1,
        0.7);
    
    var m = new THREE.Matrix4();
    var m1 = new THREE.Matrix4();
    // var m2 = new THREE.Matrix4();

    m.scale(new THREE.Vector3(1.5,1.5,1.5));        
    // m.makeTranslation(0,-8,0);
    // m.makeRotationX( -Math.PI/4 );
    m1.makeRotationX( Math.PI/2 );
    // m2.makeRotationY( Math.PI/2 );

    m.multiply(m1);
    geometry.applyMatrix(m);
        
    var r = 15;

    var arm_geo = new THREE.CylinderGeometry( .3, .3, 3, 5 );
    // var interSphere = new THREE.SphereGeometry( 5, 5, 5);
    computeFlipNormals(geometry);
    
    for (var i = 0; i < num; i++){
        var tongues = [];

        var rebar = new THREE.Mesh(
            arm_geo,
            new THREE.MeshPhongMaterial({ color: 0x664935 })
        );

        rebar.geometry.computeBoundingBox();
        rebar.geometry.computeBoundingSphere();

        rebar.castShadow = true;
        rebar.receiveShadow= true;

        var tongueSculpture = new Sculpture( rebar, tongues, 1);

        // var rotX = new THREE.Matrix4();
        // rotX.makeRotationX(-Math.PI/2);

        // rebar.geometry.applyMatrix(rotX);

        var a = (2 * Math.PI / num) * i;

        var rotY = new THREE.Matrix4();
        rotY.makeRotationY(a);
        geometry.applyMatrix(rotY);
        rebar.geometry.applyMatrix(rotY);


        var tongueMesh = new Physijs.ConvexMesh(
            geometry,
            tongueMaterial,
            7
        );
        tongueMesh.geometry.computeBoundingBox();
        tongueMesh.geometry.computeBoundingSphere();
        tongueMesh.castShadow = true;
        tongueMesh.receiveShadow = true;

        //x = cx + r * cos(a)
        //y = cy + r * sin(a)
        var xC = x + r * Math.cos(a);
        var zC = z + r * Math.sin(a);

        rebar.position.set(xC , -17, zC);

        tongueMesh.rotation.y = -a;
        rebar.rotation.y = -a;  

        scene.add( tongueMesh );
        scene.add( rebar );
    
        tongueMesh.__dirtyRotation = true;
    
        tongueMesh.setAngularFactor( module_factor );
        tongueMesh.setLinearFactor( module_factor );

        moveable_objects.push(tongueMesh);

        tongueSculpture.addModule(tongueMesh);
        //console.log(sculptures);

        var y =  i * 6 + 5;  
        tongueMesh.position.y = y;

        // sculptures.push(tongueSculpture);
    }

}

function wedgeSculpture(x, z) {
    var geometries = this;
    //console.log(geometries);
    // if we want to use this x and z then we'll need to save ply geometries globally
    if (typeof x === 'undefined') { x = -50; }
    if (typeof z === 'undefined') { z = -40; }

    var wedges = [];

    // In the future, custom armature geometry could be geometries[0]
    var armature_mat = new THREE.MeshPhongMaterial({ color: 0x664935 });

    var armature = new Physijs.BoxMesh(    
    new THREE.BoxGeometry( 26, 1, 26 ),
        armature_mat,
        9
    );

    armature.position.set(x, -15.4, z);
    
    armature.castShadow = true;
    armature.receiveShadow= true;

    scene.add( armature );
    

    armature.setAngularFactor( armature_factor );
    armature.setLinearFactor( armature_factor );

    var intersect_cylinder_one = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25,0.25,55),
        armature_mat
    );

    intersect_cylinder_one.position.set(x + .75 ,3 , z - .75);
    intersect_cylinder_one.castShadow = true;
    intersect_cylinder_one.receiveShadow = true;

    var intersect_cylinder_two = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25,0.25,55),
        armature_mat
    );

    intersect_cylinder_two.position.set(x - .75 ,3 ,z + .75);
    intersect_cylinder_two.castShadow = true;
    intersect_cylinder_two.receiveShadow = true;

    scene.add(intersect_cylinder_one);
    scene.add(intersect_cylinder_two);

    //num = 47

    var wedge_material = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xDDDDDD }),
        1,
        1
    );

    var wedgeDroop_mat = new Physijs.createMaterial (
        new THREE.MeshLambertMaterial({ color: 0xff7b00, ambient: 0xFFFFFF /*0xFF5934*/ }),
        1,
        1
    );

    computeFlipNormals(geometries[0]);
    computeFlipNormals(geometries[1]);
    computeFlipNormals(geometries[2]);


    var geometry_flat = geometries[1];
    var geometry_hammer = geometries[2];

    var m = new THREE.Matrix4();
    // var m3 = new THREE.Matrix4();
    
    var geo_flat_left = geometry_flat.clone();
    m.makeRotationY( Math.PI );        
    geometry_flat.applyMatrix(m);

    var geo_hammer_left = geometry_hammer.clone();
    m.makeRotationY( Math.PI );        
    geometry_hammer.applyMatrix(m);


    //var mX = new THREE.Matrix4();
    // var mY = new THREE.Matrix4();
    // mY.makeRotationX(Math.PI/4);
    // var mY = new THREE.Matrix4();
    // mY.makeRotationY(Math.PI/1.1);
    // mX.makeRotationX(Math.PI/2);

    // mY.multiply(mX);
    // mX.multiply(mZ);
    var wedgeDroop = geometries[0];
    var wDLeft = geometries[0].clone();
    wDLeft.applyMatrix(m);
    //wedgeDroop.applyMatrix(m);

    //wedgeDroop.computeBoundingSphere();

    //var yFactor = geometry_flat.boundingSphere.radius;
    var wedge_models = [geometry_flat, geo_flat_left, geometry_hammer, geo_hammer_left, wedgeDroop, wDLeft];
    
    var arrangement = [0, 0, 1, 0,
                        0, 1, 1, 3,
                        1, 1, 1, 3,
                        1, 0, 0, 1,
                        1, 1, 0, 1, 
                        0, 1, 0,
                        //3, 3, 3, 4,
                        3, 3, 3, 1, //
                        1, 1, 1, 4,
                        0, 2, 0, 0,
                        0, 2, 5, 1,
                        1, 3, 2, 1,0];
    
    var wedge_stack = new Sculpture( armature, wedges );
    
    //geometry_flat.computeBoundingSphere();
    // geo_flat_left.computeBoundingBox();

    // geometry_hammer.computeBoundingBox();
    // geo_hammer_left.computeBoundingBox();
    
    // wedgeDroop.computeBoundingBox();

    var r = .6;//(geometry_flat.boundingBox.max.y - geometry_flat.boundingBox.min.y) / 2;

    _v3 = new THREE.Vector3(0,0,0);

    for (var i = 0; i < arrangement.length; i++){

        var wMat;
        if (arrangement[i] > 3) {
            wMat = wedgeDroop_mat;
            var wedgeMesh = new Physijs.ConcaveMesh(
                wedge_models[arrangement[i]],
                wMat,
                30
            );
        }
        else { 
            wMat = wedge_material; 
            var wedgeMesh = new Physijs.ConvexMesh(
                wedge_models[arrangement[i]],
                wMat,
                30
            );

            //wahhh
            wedgeMesh.setCcdMotionThreshold(.01);
            wedgeMesh.setCcdSweptSphereRadius(.25);
        }


        wedgeMesh.castShadow = true;
        wedgeMesh.receiveShadow = true;

        scene.add( wedgeMesh );

        wedgeMesh.setAngularFactor( _v3 ); 
        wedgeMesh.setAngularVelocity(_v3);

        wedgeMesh.setLinearFactor( module_factor );
        wedgeMesh.setLinearVelocity(_v3);

        wedgeMesh.setDamping( 1 , 0 );

        wedge_stack.addModule(wedgeMesh);
        moveable_objects.push( wedgeMesh );



    }
}

// relates armature and modules
// idea for the future: add moduleVector to the constructor
var Sculpture = function( armature, modules, limit ) {
    this.armature = armature;
    this.modules = modules;
    // for all intents and purposes limit default is infinite
    this.limit = limit || 1000;
    //this.intersect_sphere;

    // add scupture object to array of sculptures
    sculptures.push(this);
};

Sculpture.prototype.removeModule = function( obj ) {
	this.modules.splice( this.modules.indexOf(obj), 1 );
    // obj.setAngularFactor(new THREE.Vector3[1,1,1]);
    // obj.setLinearFactor(new THREE.Vector3[1,1,1]);
	// if (this.modules.length == 0) {
	// 	moveable_objects.push(this.armature);
	// 	this.limit = 0;		
	// }
};


Sculpture.prototype.addModule = function( obj ) {
    var snap_y;
    if (!this.isAtLimit()) {
    	
        var r = (obj.geometry.boundingBox.max.y - obj.geometry.boundingBox.min.y) / 2;
        
        if (this.modules.length == 0) {
    	    snap_y = -7
    		+ this.armature.geometry.boundingBox.max.y
    		+ r;
    	}
    	
        else {
    	    snap_y = this.modules[this.modules.length-1].position.y
    		+ this.modules[this.modules.length-1].geometry.boundingBox.max.y
    		+ r;
    	}

    	//put object in position
    	obj.position.set( this.armature.position.x,
    			  snap_y,
    			  this.armature.position.z );

    	//make object static
        obj.setDamping(.9,.9);

    	_v3 = new THREE.Vector3(0,1,0);
    	obj.setLinearFactor(_v3);

    	_v3 = new THREE.Vector3(0,0,0);
    	obj.setLinearVelocity(_v3);
        obj.setAngularFactor(_v3);
        
        obj.__dirtyPosition = true;
        obj.__dirtyRotation = true;

    	//finally, push selected_thing on the sculpture stack
    	this.modules.push( obj );
    }
};

Sculpture.prototype.isAtLimit = function() {
    return ( this.modules.length >= this.limit ) ? true : false;
};

Sculpture.prototype.addIntersectSphere = function() {
    // this.intersect_sphere = new THREE.Mesh(
    // 	new THREE.SphereGeometry( 10 ),
    // 	new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 1 , transparent: true })
    // );
    
    // if (modules.length > 0) {
    // 	this.intersect_sphere.position.copy(this.modules[this.modules.length-1].position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // else {
    // 	this.intersect_sphere.position.copy(this.armature.position);
    // 	this.intersect_sphere.position.y+=3;
    // }
    // scene.add(this.intersect_sphere);

}

// Load ply objects asynchronously, calls sculpture function afterwards
// Takes asset paths as array of strings and callback function as arguments
// The arguments look like (['<%= asset_path 'ascii/Wedge_Flat.ply' %>', '<%= asset_path 'ascii/Wedge_Hammerhead.ply' %>'], wedgeSculpture)
// The function returns an array [geometry1, geometry2], accessed in callback function with keyword this
// Geometry array is returned with geometries sorted by # of verts in ascending order
function LoadPlyAssets( assetPathArray, callback ){
    //console.log("loadPlyAssets");

    // array of returned geometries
    var geometries = [];//new Array(assetPathArray.length);
    var length = assetPathArray.length;

    for (var i = 0; i < length; i++) {
        var geometry_loader = new THREE.PLYLoader();

        var geo = geometry_loader.load( assetPathArray[i], function( geometry ){
            // Problem: right now can't make sure that the first asset goes in geometries[0]
            
            geometries.push( geometry );

            if ( geometries.length == length ){
                //ensures geometries array will be returned in a predictable order
                geometries.sort(function(a, b){return a.vertices.length - b.vertices.length});
                callback.call( geometries );
            }
        });
    }
}

//user input
initEventHandling = (function() {
var handleMouseDown, handleMouseMove, handleMouseUp, handleKeyDown, handleResize;
var raycaster = new THREE.Raycaster();
var thing_offset = new THREE.Vector3;
var _vector = new THREE.Vector3();
var sculpture, collisionResults, intersections, intersection;
var spot_light_on = false;

handleResize = function( evt ) {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize( window.innerWidth, window.innerHeight );
};

handleMouseDown = function( evt ) {

camera.updateProjectionMatrix();
_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
	    -(evt.clientY / window.innerHeight ) * 2 + 1,
	    1);

raycaster.setFromCamera(_vector, camera);
intersections = raycaster.intersectObjects( moveable_objects );

if (intersections.length > 0) {
    selected_thing = intersections[0].object;

    // if it is on a sculpture, pop it and make it dynamic
    for (i = 0; i < sculptures.length; i++) {
        //for bink pox
        if (selected_thing.id == sculptures[i].armature.id) sculptures[i].modules.pop();
	    if (sculptures[i].modules.indexOf(selected_thing) >= 0) {
            sculptures[i].removeModule(selected_thing);
	    break;
	  }
    }


    _vector.set(0,0,0);
    selected_thing.setAngularFactor( _vector);
    selected_thing.setAngularVelocity( _vector);
    selected_thing.setLinearFactor( _vector);
    selected_thing.setLinearVelocity( _vector);

    mouse_position.copy(intersections[0].point);
    thing_offset.subVectors( selected_thing.position, mouse_position);

}
};

handleMouseUp = function( evt ) {

if (selected_thing !== null) {

    _vector.set(1,1,1);
    selected_thing.setAngularFactor( _vector );
    selected_thing.setLinearFactor( _vector );

    // snapping to armature
	_vector.set((evt.clientX / window.innerWidth) * 2 - 1,
		-(evt.clientY / window.innerHeight ) * 2 + 1,
		1);

    raycaster.setFromCamera(_vector, camera);

    //iterates through sculpture objects
    for (i = 0; i < sculptures.length; i++) {
        if(sculptures[i].isAtLimit()) continue;
        collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
		if (collisionResults.length !== 0) {
		    sculpture = sculptures[i];
            // for pink box extra special moveable armature
            if (selected_thing.id == sculpture.armature.id) continue;


            sculpture.addModule( selected_thing );

          //turn off spotlight
            spot_light.intensity = 0;
            // spot_light.shadow.shadowCamera.updateProjectionMatrix();
            // spot_light.visible = false;
            spot_light_on = false;
		    break;
		}
    }
    renderer.domElement.style.cursor = "default"
    //end snapping

    selected_thing = null;
}
};

handleMouseMove = function( evt ) {

_vector.set(
( evt.clientX / window.innerWidth ) * 2 - 1,
-( evt.clientY / window.innerHeight ) * 2 + 1,
1);
camera.updateProjectionMatrix();
raycaster.setFromCamera(_vector, camera);

intersection = raycaster.intersectObjects( intersect_planes );                    

if  ( intersection[0] != undefined) {
    if (selected_thing !== null) {
        mouse_position.copy(intersection[0].point);
        // renderer.domElement.style.cursor = "none";
    }
}

//iterates through sculpture objects
for (i = 0; i < sculptures.length; i++) {
    
    // if (sculptures[i].isAtLimit()) continue;
    
    collisionResults = raycaster.intersectObjects(sculptures[i].modules.concat(sculptures[i].armature));
    
    if (collisionResults.length !== 0) {
        sculpture = sculptures[i];
        
        if (selected_thing !== null && sculpture.isAtLimit()) {
            
            continue;
        }
        // for pink box extra special moveable armature
        if (selected_thing !== null && selected_thing.id == sculpture.armature.id) continue;

        renderer.domElement.style.cursor = "pointer";

        // if (selected_thing == null) {
            // cameraTarget = sculpture.armature.position.clone().multiplyScalar(factor).add(cameraTarget.clone().multiplyScalar(1-factor));
            // camera.lookAt(cameraTarget);
        // }

        //make a light source directly above the sculpture
        //if (spot_light.visible == false) spot_light.visible = true;
        // console.log(spot_light);
        var y = 0;

        if (sculpture.modules.length > 0) { 
            y += sculpture.modules[sculpture.modules.length-1].position.y
            + sculpture.modules[sculpture.modules.length-1].geometry.boundingBox.max.y;
        }

        y += 10;

        // spot_light.distance = y + 5;
        // spot_light.position.set( sculpture.armature.position.x, y, sculpture.armature.position.z );
        spot_light.target = sculpture.armature;
        spot_light.intensity = 2;

        // spot_light.shadow.shadowCamera.updateProjectionMatrix();
        spot_light_on = true;
        break;
    }
    else {
        renderer.domElement.style.cursor = "default";
    }
}
};
//rotate camera
handleKeyDown =  function( evt ){

    var x = camera.position.x,
        y = camera.position.y,
        z = camera.position.z;
    var rotSpeed = 0.05;

    if (evt.keyCode=="37"){
        camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
        camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
    }

    else if (evt.keyCode=="39"){
        camera.position.x = x * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
        camera.position.z = z * Math.cos(rotSpeed) + x * Math.sin(rotSpeed);
    }

    camera.lookAt(scene.position);

    }

    return function() {
    renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
    renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
    renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
    renderer.domElement.addEventListener( 'keydown', handleKeyDown );
    window.addEventListener('resize', handleResize );
    };

})();

//render loop
                // renderer.domElement.style.cursor = "default";
                // cameraTarget = scene.position.clone().multiplyScalar(factor).add(cameraTarget.clone().multiplyScalar(1-factor));
                // camera.lookAt(cameraTarget);
render = function() {
    if (renderer.domElement.style.cursor == "default"){
        // cameraTarget = scene.position.clone().multiplyScalar(factor).add(cameraTarget.clone().multiplyScalar(1-(factor)));
        // camera.lookAt(cameraTarget);
        if (spot_light.intensity > 0) {
            spot_light.intensity -= .03;
            // spot_light.shadow.shadowCamera.updateProjectionMatrix();
        }
        else {
                spot_light.intensity = 0;
                // spot_light.shadow.shadowCamera.updateProjectionMatrix();
        }
    }
    scene.simulate(); // run physics
    renderer.render( scene, camera); // render the scene
    requestAnimationFrame( render );
};

computeFlipNormals = function(geometry){
    /* Compute normals */
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    /* Next 3 lines seems not to be mandatory */
    geometry.dynamic = true
    geometry.__dirtyVertices = true;
    geometry.__dirtyNormals = true;

    // mesh.flipSided = true;
    // mesh.doubleSided = true;

    /* Flip normals*/               
    for(var i = 0; i<geometry.faces.length; i++) {
        geometry.faces[i].normal.x = -1* geometry.faces[i].normal.x;
        geometry.faces[i].normal.y = -1* geometry.faces[i].normal.y;
        geometry.faces[i].normal.z = -1* geometry.faces[i].normal.z;
    }
}

initScene();
</script>
    
